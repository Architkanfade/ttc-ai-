<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIC TAC TOE</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from fireworks canvas */
        }
        .cell {
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        @media (max-width: 400px) {
            .cell {
                width: 80px;
                height: 80px;
                font-size: 2.5rem;
            }
        }
        .cell.x { color: #38bdf8; } /* sky-500 */
        .cell.o { color: #fb923c; } /* orange-400 */
        .game-shadow {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
        /* Hide elements by default */
        .hidden { display: none; }
        
        /* Fireworks Canvas */
        #fireworksCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 9999;
        }
        
        /* Winning Line SVG */
        #winning-line {
            stroke: #ef4444; /* red-500 */
            stroke-width: 10; /* Made the line thicker */
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            transition: stroke-dashoffset 0.5s ease-in-out;
        }
        /* Chat box scrollbar */
        #chatMessages::-webkit-scrollbar {
            width: 6px;
        }
        #chatMessages::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }
        #chatMessages::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 3px;
        }
        .dark #chatMessages::-webkit-scrollbar-track {
            background: #1e293b; /* slate-800 */
        }
        .dark #chatMessages::-webkit-scrollbar-thumb {
            background: #475569; /* slate-600 */
        }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex items-center justify-center min-h-screen p-4">
    
    <canvas id="fireworksCanvas"></canvas>

    <!-- Main Container -->
    <div class="w-full max-w-4xl mx-auto text-center">

        <!-- Mode Selection View -->
        <div id="modeSelectionView" class="max-w-md mx-auto">
            <h1 class="text-4xl md:text-5xl font-bold mb-8 uppercase">TIC TAC TOE</h1>
            <div class="space-y-4">
                <div class="relative inline-block w-full">
                    <button id="singlePlayerDropdownButton" class="w-full bg-sky-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-sky-600 transition-all flex items-center justify-center">
                        Single Player (vs AI)
                        <svg class="ml-2 w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <div id="difficultyDropdown" class="hidden absolute w-full mt-2 bg-white dark:bg-slate-700 rounded-lg shadow-xl z-10">
                        <a href="#" class="block px-4 py-3 text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600 rounded-t-lg difficulty-option" data-difficulty="easy">Easy</a>
                        <a href="#" class="block px-4 py-3 text-slate-700 dark:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-600 rounded-b-lg difficulty-option" data-difficulty="hard">Hard (Unbeatable)</a>
                    </div>
                </div>
                <button id="multiplayerButton" class="w-full bg-indigo-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-600 transition-all">Multiplayer</button>
            </div>
        </div>

        <!-- Sign-In View -->
        <div id="signInView" class="hidden max-w-md mx-auto">
            <h1 class="text-4xl md:text-5xl font-bold mb-4 uppercase">TIC TAC TOE</h1>
            <p id="signInStatus" class="text-slate-600 dark:text-slate-400 mb-8">Sign in to play with a friend.</p>
            <button id="signInButton" class="w-full bg-white text-gray-700 font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition-all duration-300 flex items-center justify-center border border-gray-300 disabled:opacity-75">
                <svg id="googleIcon" class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24s8.955,20,20,20s20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"></path><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"></path><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.222,0-9.655-3.373-11.303-8H6.306C9.656,39.663,16.318,44,24,44z"></path><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.089,5.571l6.19,5.238C42.018,35.27,44,30.022,44,24C44,22.659,43.862,21.35,43.611,20.083z"></path></svg>
                <svg id="spinnerIcon" class="hidden animate-spin mr-3 h-5 w-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="signInButtonText">Sign in with Google</span>
            </button>
        </div>

        <!-- Lobby View -->
        <div id="lobbyView" class="hidden max-w-md mx-auto">
            <h2 class="text-2xl font-bold mb-2">Welcome!</h2>
            <p class="text-slate-600 dark:text-slate-400 mb-2">Your User ID: <strong id="userIdDisplay" class="text-slate-700 dark:text-slate-300 break-all"></strong></p>
            <p class="text-slate-500 dark:text-slate-500 mb-6 text-sm">Share your User ID with a friend, or use theirs to create a unique Game ID.</p>
            
            <div class="bg-white dark:bg-slate-800 p-6 rounded-lg game-shadow">
                <label for="gameIdInput" class="font-semibold block mb-2 text-left">Create or Join a Game</label>
                <input type="text" id="gameIdInput" placeholder="Enter a custom Game ID" class="w-full p-3 bg-slate-200 dark:bg-slate-700 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500">
                <button id="joinGameButton" class="w-full mt-4 bg-sky-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-sky-600 focus:outline-none focus:ring-2 focus:ring-sky-400 transition-all">
                    Start Game
                </button>
            </div>
             <button id="signOutButton" class="mt-6 text-sm text-slate-500 hover:text-sky-500">Back to Mode Selection</button>
        </div>

        <!-- Game View -->
        <div id="gameView" class="hidden">
            <div class="flex flex-col md:flex-row gap-8 justify-center items-start">
                <!-- Game Board Section -->
                <div class="w-full md:w-2/3">
                    <h1 id="gameTitle" class="text-3xl md:text-4xl font-bold mb-2"></h1>
                    <p id="status" class="text-lg md:text-xl text-slate-600 dark:text-slate-400 mb-4 h-8 transition-all"></p>
                    <p id="playerInfo" class="text-md text-slate-500 dark:text-slate-400 mb-4 h-6"></p>

                    <div class="relative mx-auto" style="width: 308px; height: 308px;">
                        <div id="board" class="grid grid-cols-3 gap-2 bg-slate-300 dark:bg-slate-700 p-2 rounded-lg game-shadow absolute inset-0">
                            <!-- 3x3 grid -->
                            <div data-cell-index="0" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="1" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="2" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="3" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="4" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="5" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="6" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="7" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                            <div data-cell-index="8" class="cell rounded-md bg-slate-100 dark:bg-slate-800 hover:bg-slate-200 dark:hover:bg-slate-700"></div>
                        </div>
                         <svg id="board-overlay" class="absolute inset-0 w-full h-full" style="pointer-events: none;">
                            <line id="winning-line" x1="0" y1="0" x2="0" y2="0" />
                        </svg>
                    </div>
                    
                    <div id="replayView" class="hidden mt-8 text-center">
                        <p id="replayStatus" class="mb-4 text-lg"></p>
                        <button id="replayButton" class="px-6 py-3 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 disabled:opacity-50">Request Replay</button>
                    </div>

                    <button id="leaveGameButton" class="mt-8 px-6 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600">
                        Leave Game
                    </button>
                </div>

                <!-- Chat Section -->
                <div id="chatContainer" class="hidden w-full md:w-1/3">
                     <div class="bg-white dark:bg-slate-800 p-4 rounded-lg game-shadow h-[450px] flex flex-col">
                        <h2 class="text-xl font-bold mb-2 border-b border-slate-200 dark:border-slate-700 pb-2">Chat</h2>
                        <div id="chatMessages" class="flex-grow overflow-y-auto mb-2 text-left text-sm space-y-2 pr-2">
                            <!-- Messages will be injected here -->
                        </div>
                        <div class="relative">
                            <div id="quickChatOptions" class="hidden absolute bottom-full mb-2 w-full bg-slate-100 dark:bg-slate-700 rounded-lg shadow-lg p-2 space-y-1">
                                <!-- Quick chat options here -->
                            </div>
                            <button id="quickChatButton" class="absolute left-2 top-1/2 -translate-y-1/2 text-slate-500 hover:text-sky-500">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            </button>
                            <input type="text" id="chatInput" placeholder="Type a message..." class="w-full p-2 pl-10 pr-16 bg-slate-200 dark:bg-slate-700 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500">
                            <button id="sendChatButton" class="absolute right-2 top-1/2 -translate-y-1/2 bg-sky-500 text-white px-3 py-1 rounded-md text-sm font-semibold hover:bg-sky-600">Send</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, deleteField, collection, addDoc, query, orderBy, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'tictactoe-default';
        const firebaseConfig = {
            apiKey: "AIzaSyBGwdUwsNlKYxkL3D95YEfdybg3Ls_nN4M",
            authDomain: "tic-tac-toe-4410e.firebaseapp.com",
            projectId: "tic-tac-toe-4410e",
            storageBucket: "tic-tac-toe-4410e.appspot.com",
            messagingSenderId: "29627705587",
            appId: "1:29627705587:web:fb1e8d647c08494b0c6f86",
            measurementId: "G-BQFZL8H7DZ"
       };

        // Initialize Firebase
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            document.body.innerHTML = '<p class="text-red-500 text-center">Error: Could not connect to Firebase. Please check the console.</p>';
        }

        // --- Sound Synthesis ---
        let synth;
        // Initialize synth on the first user interaction
        document.body.addEventListener('click', () => {
            if (Tone.context.state !== 'running') {
                Tone.context.resume();
            }
            if (!synth) {
                synth = new Tone.Synth().toDestination();
            }
        }, { once: true });

        function playMoveSound(player) {
            if (synth && Tone.context.state === 'running') {
                const note = player === 'X' ? 'C4' : 'E4';
                synth.triggerAttackRelease(note, "8n", Tone.now());
            }
        }
        
        function playWinSound() {
             if (synth && Tone.context.state === 'running') {
                const now = Tone.now();
                synth.triggerAttackRelease("C5", "8n", now);
                synth.triggerAttackRelease("E5", "8n", now + 0.2);
                synth.triggerAttackRelease("G5", "8n", now + 0.4);
            }
        }

        // --- DOM Element References ---
        const modeSelectionView = document.getElementById('modeSelectionView');
        const singlePlayerDropdownButton = document.getElementById('singlePlayerDropdownButton');
        const difficultyDropdown = document.getElementById('difficultyDropdown');
        const multiplayerButton = document.getElementById('multiplayerButton');
        const signInView = document.getElementById('signInView');
        const lobbyView = document.getElementById('lobbyView');
        const gameView = document.getElementById('gameView');
        const signInButton = document.getElementById('signInButton');
        const signOutButton = document.getElementById('signOutButton');
        const joinGameButton = document.getElementById('joinGameButton');
        const leaveGameButton = document.getElementById('leaveGameButton');
        const gameTitle = document.getElementById('gameTitle');
        const statusDisplay = document.getElementById('status');
        const playerInfo = document.getElementById('playerInfo');
        const cells = document.querySelectorAll('.cell');
        const winningLine = document.getElementById('winning-line');
        const replayView = document.getElementById('replayView');
        const replayButton = document.getElementById('replayButton');
        const replayStatus = document.getElementById('replayStatus');
        const chatContainer = document.getElementById('chatContainer');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const quickChatButton = document.getElementById('quickChatButton');
        const quickChatOptions = document.getElementById('quickChatOptions');

        // --- Game State Variables ---
        let gameMode = null; // 'single' or 'multi'
        let difficulty = 'easy'; // 'easy' or 'hard'
        let currentUser = null;
        let currentGameId = null;
        let unsubscribeGameListener = null; 
        let unsubscribeChatListener = null;
        
        // Single Player State
        let singlePlayerState = {
            board: Array(9).fill(''),
            currentPlayer: 'X',
            gameActive: true
        };

        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];
        
        const quickChatMessages = ["Good luck!", "Nice move!", "You're good at this!", "Well played.", "GG"];

        // --- Mode Selection ---
        singlePlayerDropdownButton.addEventListener('click', () => {
            difficultyDropdown.classList.toggle('hidden');
        });

        document.querySelectorAll('.difficulty-option').forEach(option => {
            option.addEventListener('click', (e) => {
                e.preventDefault();
                difficulty = e.target.dataset.difficulty;
                gameMode = 'single';
                modeSelectionView.classList.add('hidden');
                difficultyDropdown.classList.add('hidden');
                gameView.classList.remove('hidden');
                chatContainer.classList.add('hidden');
                startSinglePlayerGame();
            });
        });

        multiplayerButton.addEventListener('click', () => {
            gameMode = 'multi';
            modeSelectionView.classList.add('hidden');
            if (currentUser) {
                lobbyView.classList.remove('hidden');
            } else {
                signInView.classList.remove('hidden');
            }
        });

        // --- Authentication ---
        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            if (gameMode === 'multi') {
                if (user) {
                    signInView.classList.add('hidden');
                    lobbyView.classList.remove('hidden');
                    document.getElementById('userIdDisplay').textContent = user.uid;
                } else {
                    signInView.classList.remove('hidden');
                    lobbyView.classList.add('hidden');
                    if (unsubscribeGameListener) unsubscribeGameListener();
                    if (unsubscribeChatListener) unsubscribeChatListener();
                }
            }
        });

        signInButton.addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Sign in failed", error);
            }
        });

        signOutButton.addEventListener('click', async () => {
            if (gameMode === 'multi') {
                await signOut(auth);
            }
            lobbyView.classList.add('hidden');
            modeSelectionView.classList.remove('hidden');
        });

        // --- Game Logic ---
        
        function handleCellClick(event) {
            const cellIndex = parseInt(event.target.getAttribute('data-cell-index'));
            if (gameMode === 'single') {
                handleSinglePlayerMove(cellIndex);
            } else if (gameMode === 'multi') {
                handleMultiplayerMove(cellIndex);
            }
        }

        cells.forEach(cell => cell.addEventListener('click', handleCellClick));

        leaveGameButton.addEventListener('click', () => {
            gameView.classList.add('hidden');
            modeSelectionView.classList.remove('hidden');
            if (unsubscribeGameListener) unsubscribeGameListener();
            if (unsubscribeChatListener) unsubscribeChatListener();
            resetBoardUI();
        });
        
        // --- Single Player Mode ---
        
        function startSinglePlayerGame() {
            gameTitle.textContent = `VS AI (${difficulty.toUpperCase()})`;
            playerInfo.textContent = 'You are Player X';
            singlePlayerState = {
                board: Array(9).fill(''),
                currentPlayer: 'X',
                gameActive: true
            };
            resetBoardUI();
            updateSinglePlayerUI();
        }

        function handleSinglePlayerMove(cellIndex) {
            if (!singlePlayerState.gameActive || singlePlayerState.board[cellIndex] !== '' || singlePlayerState.currentPlayer !== 'X') {
                return;
            }
            
            playMoveSound('X');
            singlePlayerState.board[cellIndex] = 'X';
            singlePlayerState.currentPlayer = 'O';
            updateSinglePlayerUI();
            
            const winner = checkWinner(singlePlayerState.board);
            if (winner) {
                endSinglePlayerGame(winner);
                return;
            }
            if (isBoardFull(singlePlayerState.board)) {
                endSinglePlayerGame('Draw');
                return;
            }

            // AI's turn
            setTimeout(makeAIMove, 500);
        }

        function makeAIMove() {
            if (!singlePlayerState.gameActive) return;

            let move;
            if (difficulty === 'easy') {
                let availableCells = [];
                singlePlayerState.board.forEach((cell, index) => {
                    if (cell === '') availableCells.push(index);
                });
                move = availableCells[Math.floor(Math.random() * availableCells.length)];
            } else { // Hard mode
                move = findBestMove(singlePlayerState.board);
            }
            
            playMoveSound('O');
            singlePlayerState.board[move] = 'O';
            singlePlayerState.currentPlayer = 'X';
            updateSinglePlayerUI();

            const winner = checkWinner(singlePlayerState.board);
            if (winner) {
                endSinglePlayerGame(winner);
                return;
            }
             if (isBoardFull(singlePlayerState.board)) {
                endSinglePlayerGame('Draw');
                return;
            }
        }
        
        function updateSinglePlayerUI() {
            singlePlayerState.board.forEach((value, index) => {
                cells[index].textContent = value;
                cells[index].classList.remove('x', 'o');
                if (value) cells[index].classList.add(value.toLowerCase());
            });
            statusDisplay.textContent = singlePlayerState.gameActive ? `Player ${singlePlayerState.currentPlayer}'s turn` : statusDisplay.textContent;
        }

        function endSinglePlayerGame(winner) {
            singlePlayerState.gameActive = false;
            if (winner === 'Draw') {
                statusDisplay.textContent = "It's a draw!";
            } else {
                statusDisplay.textContent = `Player ${winner} has won!`;
                const winningCombo = getWinningCombo(singlePlayerState.board);
                drawWinningLine(winningCombo);
                playWinSound();
                if (winner === 'X') {
                    triggerFireworks();
                }
            }
            replayView.classList.remove('hidden');
            replayButton.textContent = "Play Again";
            replayStatus.textContent = '';
        }

        // --- Minimax AI for Hard Mode ---
        function findBestMove(board) {
            let bestVal = -1000;
            let bestMove = -1;

            for (let i = 0; i < 9; i++) {
                if (board[i] === '') {
                    board[i] = 'O'; // AI is 'O'
                    let moveVal = minimax(board, 0, false);
                    board[i] = ''; // Undo move
                    if (moveVal > bestVal) {
                        bestMove = i;
                        bestVal = moveVal;
                    }
                }
            }
            return bestMove;
        }

        function minimax(board, depth, isMax) {
            let score = evaluate(board);
            if (score === 10) return score - depth;
            if (score === -10) return score + depth;
            if (isBoardFull(board)) return 0;

            if (isMax) { // Maximizer's move (AI)
                let best = -1000;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        best = Math.max(best, minimax(board, depth + 1, !isMax));
                        board[i] = '';
                    }
                }
                return best;
            } else { // Minimizer's move (Player)
                let best = 1000;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'X';
                        best = Math.min(best, minimax(board, depth + 1, !isMax));
                        board[i] = '';
                    }
                }
                return best;
            }
        }

        function evaluate(b) {
            for (const condition of winningConditions) {
                const [a, b_idx, c] = condition;
                if (b[a] && b[a] === b[b_idx] && b[a] === b[c]) {
                    if (b[a] === 'O') return 10; // AI wins
                    if (b[a] === 'X') return -10; // Player wins
                }
            }
            return 0; // No winner yet
        }


        // --- Multiplayer Mode ---
        
        joinGameButton.addEventListener('click', async () => {
            const gameId = document.getElementById('gameIdInput').value.trim();
            if (!gameId || !currentUser) return;
            
            currentGameId = gameId;
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            const gameSnap = await getDoc(gameRef);

            // Room cleanup logic
            if (gameSnap.exists()) {
                const gameData = gameSnap.data();
                const lastUpdated = gameData.lastUpdated?.toDate();
                const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
                if (lastUpdated && lastUpdated < fiveMinutesAgo) {
                    await deleteDoc(gameRef); // Delete stale room
                    createNewGame(gameRef, gameId); // Create a new one
                } else {
                    joinExistingGame(gameRef, gameData);
                }
            } else {
                createNewGame(gameRef, gameId);
            }
            
            lobbyView.classList.add('hidden');
            gameView.classList.remove('hidden');
            chatContainer.classList.remove('hidden');
            gameTitle.innerHTML = `Game ID: <span class="text-sky-500">${gameId}</span>`;
            listenToGameUpdates(gameId);
            listenToChatUpdates(gameId);
        });
        
        async function createNewGame(gameRef, gameId) {
             await setDoc(gameRef, {
                board: Array(9).fill(''),
                players: { X: currentUser.uid, O: null },
                currentPlayer: 'X',
                status: 'waiting',
                gameId: gameId,
                lastUpdated: serverTimestamp()
            });
        }
        
        async function joinExistingGame(gameRef, gameData) {
            if (!gameData.players.O && gameData.players.X !== currentUser.uid) {
                await updateDoc(gameRef, { 
                    'players.O': currentUser.uid, 
                    status: 'active',
                    lastUpdated: serverTimestamp()
                });
            }
        }

        async function handleMultiplayerMove(cellIndex) {
            if (!currentGameId) return;

            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) return;

            const gameData = gameSnap.data();
            const mySymbol = gameData.players.X === currentUser.uid ? 'X' : 'O';

            if (gameData.status === 'active' && gameData.currentPlayer === mySymbol && gameData.board[cellIndex] === '') {
                playMoveSound(mySymbol);
                const newBoard = [...gameData.board];
                newBoard[cellIndex] = mySymbol;
                const winner = checkWinner(newBoard);
                let newStatus = winner ? 'win' : (isBoardFull(newBoard) ? 'draw' : 'active');
                
                await updateDoc(gameRef, {
                    board: newBoard,
                    currentPlayer: mySymbol === 'X' ? 'O' : 'X',
                    status: newStatus,
                    lastUpdated: serverTimestamp()
                });
            }
        }

        function listenToGameUpdates(gameId) {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, gameId);
            unsubscribeGameListener = onSnapshot(gameRef, (doc) => {
                if (doc.exists()) {
                    updateMultiplayerUI(doc.data());
                } else {
                    leaveGameButton.click();
                }
            });
        }

        function updateMultiplayerUI(gameData) {
            resetBoardUI();
            gameData.board.forEach((value, index) => {
                cells[index].textContent = value;
                if (value) cells[index].classList.add(value.toLowerCase());
            });

            const mySymbol = gameData.players.X === currentUser.uid ? 'X' : 'O';
            playerInfo.textContent = `You are Player ${mySymbol}`;

            const winner = checkWinner(gameData.board);
            const opponentId = Object.values(gameData.players).find(id => id !== currentUser.uid);

            if (gameData.status === 'win' || gameData.status === 'draw') {
                replayView.classList.remove('hidden');
                replayButton.disabled = false;
                
                if (gameData.status === 'win') {
                    statusDisplay.textContent = winner === mySymbol ? 'You won!' : 'You lost!';
                    const winningCombo = getWinningCombo(gameData.board);
                    drawWinningLine(winningCombo);
                    if (winner === mySymbol) {
                        playWinSound();
                        triggerFireworks();
                    }
                } else {
                    statusDisplay.textContent = "It's a draw!";
                }

                // Replay logic
                const replayRequests = gameData.replayRequest || {};
                if (replayRequests[currentUser.uid]) {
                    replayButton.disabled = true;
                    replayStatus.textContent = 'Waiting for opponent...';
                } else if (opponentId && replayRequests[opponentId]) {
                    replayButton.textContent = 'Accept Replay';
                    replayStatus.textContent = 'Opponent wants a replay!';
                } else {
                    replayButton.textContent = 'Request Replay';
                    replayStatus.textContent = '';
                }

            } else {
                replayView.classList.add('hidden');
                if (gameData.status === 'waiting') {
                    statusDisplay.textContent = 'Waiting for Player O...';
                } else {
                    statusDisplay.textContent = gameData.currentPlayer === mySymbol ? 'Your turn!' : "Opponent's turn";
                }
            }
        }

        // --- Replay Logic ---
        replayButton.addEventListener('click', () => {
            if (gameMode === 'single') {
                startSinglePlayerGame();
            } else {
                handleReplayRequest();
            }
        });

        async function handleReplayRequest() {
            const gameRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            
            // Using dot notation for atomic update is crucial here
            const updatePayload = {};
            updatePayload[`replayRequest.${currentUser.uid}`] = true;
            await updateDoc(gameRef, updatePayload);
            
            // Refetch the document to check the latest state
            const updatedGameSnap = await getDoc(gameRef);
            const updatedGameData = updatedGameSnap.data();
            const replayRequests = updatedGameData.replayRequest || {};

            if (Object.keys(replayRequests).length === 2) {
                // Both players agreed, reset game
                await updateDoc(gameRef, {
                    board: Array(9).fill(''),
                    currentPlayer: 'X',
                    status: 'active',
                    replayRequest: deleteField(),
                    lastUpdated: serverTimestamp()
                });
            }
        }
        
        // --- Chat Logic ---
        function listenToChatUpdates(gameId) {
            const chatRef = collection(db, `artifacts/${appId}/public/data/games`, gameId, 'chat');
            const q = query(chatRef, orderBy('timestamp'));
            
            unsubscribeChatListener = onSnapshot(q, (snapshot) => {
                chatMessages.innerHTML = '';
                snapshot.forEach(doc => {
                    const msg = doc.data();
                    const messageElement = document.createElement('div');
                    const isMe = msg.senderId === currentUser.uid;
                    messageElement.classList.add('p-2', 'rounded-lg', 'max-w-[80%]', 'w-fit', isMe ? 'bg-sky-100 dark:bg-sky-900 self-end' : 'bg-slate-200 dark:bg-slate-700 self-start');
                    messageElement.textContent = msg.text;
                    chatMessages.appendChild(messageElement);
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
        }
        
        async function sendChatMessage(text) {
            if (!text.trim() || !currentGameId) return;
            const chatRef = collection(db, `artifacts/${appId}/public/data/games`, currentGameId, 'chat');
            await addDoc(chatRef, {
                text: text.trim(),
                senderId: currentUser.uid,
                timestamp: serverTimestamp()
            });
        }
        
        sendChatButton.addEventListener('click', () => {
            sendChatMessage(chatInput.value);
            chatInput.value = '';
        });
        
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage(chatInput.value);
                chatInput.value = '';
            }
        });
        
        quickChatButton.addEventListener('click', () => {
            quickChatOptions.classList.toggle('hidden');
        });
        
        // Populate quick chat options
        quickChatOptions.innerHTML = ''; // Clear old options before repopulating
        quickChatMessages.forEach(msg => {
            const option = document.createElement('a');
            option.href = '#';
            option.textContent = msg;
            option.classList.add('block', 'p-2', 'hover:bg-slate-200', 'dark:hover:bg-slate-600', 'rounded');
            option.onclick = (e) => {
                e.preventDefault();
                sendChatMessage(msg);
                quickChatOptions.classList.add('hidden');
            };
            quickChatOptions.appendChild(option);
        });


        // --- UI & Helper Functions ---
        
        function resetBoardUI() {
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('x', 'o');
            });
            winningLine.setAttribute('x1', '0');
            winningLine.setAttribute('y1', '0');
            winningLine.setAttribute('x2', '0');
            winningLine.setAttribute('y2', '0');
            winningLine.style.strokeDashoffset = 1000;
            replayView.classList.add('hidden');
        }

        function checkWinner(board) {
            for (const condition of winningConditions) {
                const [a, b, c] = condition;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }
            return null;
        }
        
        function getWinningCombo(board) {
            for (const condition of winningConditions) {
                const [a, b, c] = condition;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return condition;
                }
            }
            return null;
        }

        function isBoardFull(board) {
            return !board.includes('');
        }
        
        function drawWinningLine(winningCombo) {
            if (!winningCombo) return;
            
            // Use fixed positions for reliability
            const positions = [
                { x: 52, y: 52 }, { x: 154, y: 52 }, { x: 256, y: 52 },
                { x: 52, y: 154 }, { x: 154, y: 154 }, { x: 256, y: 154 },
                { x: 52, y: 256 }, { x: 154, y: 256 }, { x: 256, y: 256 }
            ];

            const startPos = positions[winningCombo[0]];
            const endPos = positions[winningCombo[2]];
            
            winningLine.setAttribute('x1', startPos.x);
            winningLine.setAttribute('y1', startPos.y);
            winningLine.setAttribute('x2', endPos.x);
            winningLine.setAttribute('y2', endPos.y);
            
            // Animate the line drawing
            setTimeout(() => {
                winningLine.style.strokeDashoffset = 0;
            }, 100);
        }
        
        // --- Fireworks ---
        const fireworksCanvas = document.getElementById('fireworksCanvas');
        const ctx = fireworksCanvas.getContext('2d');
        let particles = [];
        let animationFrameId;

        function triggerFireworks() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            particles = [];
            ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

            fireworksCanvas.width = window.innerWidth;
            fireworksCanvas.height = window.innerHeight;
            
            // Create a few explosions
            for (let i = 0; i < 7; i++) {
                setTimeout(() => {
                    const x = Math.random() * fireworksCanvas.width;
                    const y = Math.random() * (fireworksCanvas.height / 2);
                    createExplosion(x, y);
                }, Math.random() * 1000);
            }
            
            animateFireworks();
        }
        
        function createExplosion(x, y) {
            const particleCount = 150;
            const angleIncrement = (Math.PI * 2) / particleCount;
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(x, y, i * angleIncrement));
            }
        }

        class Particle {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                const speed = Math.random() * 6 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.alpha = 1;
                this.gravity = 0.08;
                this.friction = 0.98;
                this.color = `hsl(${Math.random() * 360}, 100%, 60%)`;
            }

            update() {
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.015;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        function animateFireworks() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            
            particles.forEach((p, index) => {
                if (p.alpha <= 0) {
                    particles.splice(index, 1);
                } else {
                    p.update();
                    p.draw();
                }
            });

            if (particles.length > 0) {
                animationFrameId = requestAnimationFrame(animateFireworks);
            } else {
                ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
                cancelAnimationFrame(animationFrameId);
            }
        }

    </script>
</body>
</ht